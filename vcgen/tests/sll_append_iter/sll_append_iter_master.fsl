/*
Iterative version of the following function:

SNnode * sll_append(SNnode * x1, SNnode * x2)
  /*D_requires (sll^(x1) * sll^(x2)) */
  /*D_ensures  (sll^(ret) & (keys^(ret) s= (old(keys^(x1)) union old(keys^(x2))))) */
{
	if (x1 == NULL) {
		return x2;
	} else {
	    SNode * head = x1;
	    SNode * n = x1->next;
		while (n != NULL)
		/*D_invariant lseg^(head,x1) * x1 |-> n * sll^(n) * sll^(x2) & keyseg^(head,x1) union {key(x1)} union keys^(n) union keys^(x2) s= (old(keys^(head)) union old(keys^(x2)))*/
		{
		    x1 = n;
		    n = x1->next;
		}
        x1->next = x2;
		return head;
	}

}

*/

(Const nil Loc)
(Function next Loc Loc)
(Function key Loc Int)

(Var var1 Loc)
(Var var2 Loc)

(RecFunction List Loc Bool)
(RecDef (List var1) (ite (= var1 nil) True (and (not (IsMember (var1)  (SPList (next var1)))) (List (next var1)))) )

(RecFunction Lseg Loc Loc Bool)
(RecDef (Lseg var1 var2) (ite (= var1 var2) True (and (not (IsMember (var1)  (SPLseg (next var1) var2))) (Lseg (next var1) var2))) )

(RecFunction Keys Loc SetInt)
(RecDef (Keys var1) (ite (= var1 nil) EmptySetInt (SetAdd (Keys (next var1)) (key var1)) ))

(RecFunction Keyseg Loc Loc SetInt)
(RecDef (Keyseg var1 var2) (ite (= var1 var2) EmptySetInt (SetAdd (Keyseg (next var1) var2) (key var1)) ))

(Var x Loc)
(Var y Loc)
(Var head Loc)
(Var n Loc)
(Var ret Loc)

/*VC: x = nil*/

(Pre (and
 (List x)
 (List y)
 (= (Intersect (Sp (List x)) (Sp (List y))) EmptySetLoc)
))

/* instantiated lemma */
(assume (= (SPList y) (SPKeys y)))

(assume (= x nil))
(assign ret y)

(Post (and
 (List ret)
 (= (Keys ret) (Union (Old (Keys x)) (Old (Keys y))))
))

/*VC: x != nil, precondition to loop invariant*/

(Pre (and
 (List x)
 (List y)
 (= (Intersect (Sp (List x)) (Sp (List y))) EmptySetLoc)
))

/* instantiated lemmas */
(assume (= (SPKeys x) (SPList x)))
(assume (= (SPKeys y) (SPList y)))
(assume (= (SPKeyseg head x) (SPLseg head x)))
(assume (=> (and (Lseg head x) (Lseg x n)) (Lseg head n)))
(assume (= (Union (SPLseg head x) (SPLseg x n)) (SPLseg head n)))
(assume (= (Union (Keyseg head x) (Keyseg x n)) (Keyseg head n)))
(assume (= (Union (Keyseg head n) (Keys n)) (Keys head)))

(assume (not (= x nil)))
(assign head x)
(assign n (next x))

(Post (and
 (Lseg head x)
 (= (next x) n)
 (List n)
 (List y)
 (= (Intersect (Sp (Lseg head x)) (Sp (Lseg x n))) EmptySetLoc)
 (= (Intersect (Sp (Lseg head x)) (Sp (List n))) EmptySetLoc)
 (= (Intersect (Sp (Lseg head x)) (Sp (List y))) EmptySetLoc)
 (= (Intersect (Sp (Lseg x n)) (Sp (List n))) EmptySetLoc)
 (= (Intersect (Sp (Lseg x n)) (Sp (List y))) EmptySetLoc)
 (= (Intersect (Sp (List n)) (Sp (List y))) EmptySetLoc)
 (= (Union (SetAdd (Keyseg head x) (key x)) (Union (Keys n) (Keys y))) (Union (Old (Keys head)) (Old (Keys y))))
))


/*VC: loop entrance through invariant invariance*/

(Pre (and
 (Lseg head x)
 (= (next x) n)
 (List n)
 (List y)
 (= (Intersect (Sp (Lseg head x)) (Sp (Lseg x n))) EmptySetLoc)
 (= (Intersect (Sp (Lseg head x)) (Sp (List n))) EmptySetLoc)
 (= (Intersect (Sp (Lseg head x)) (Sp (List y))) EmptySetLoc)
 (= (Intersect (Sp (Lseg x n)) (Sp (List n))) EmptySetLoc)
 (= (Intersect (Sp (Lseg x n)) (Sp (List y))) EmptySetLoc)
 (= (Intersect (Sp (List n)) (Sp (List y))) EmptySetLoc)
 (= (Union (SetAdd (Keyseg head x) (key x)) (Union (Keys n) (Keys y))) (Union (Old (Keys head)) (Old (Keys y))))
))


/* instantiated lemmas */
(assume (= (SPKeys n) (SPList n)))
(assume (= (SPKeys y) (SPList y)))
(assume (= (SPKeyseg head n) (SPLseg head n)))
(assume (=> (and (Lseg head x) (Lseg x n)) (Lseg head n)))
(assume (= (Union (SPLseg head x) (SPLseg x n)) (SPLseg head n)))
(assume (= (Union (Keyseg head x) (Keyseg x n)) (Keyseg head n)))
(assume (= (Union (SPKeyseg head x) (SPKeyseg x n)) (SPKeyseg head n))) /* implied by other lemmas */

(assume (not (= n nil)))
(assign x n)
(assign n (next x))

/* instantiated lemmas */
(assume (= (SPKeyseg head n) (SPLseg head n)))
(assume (=> (and (Lseg head x) (Lseg x n)) (Lseg head n)))
(assume (= (Union (SPLseg head x) (SPLseg x n)) (SPLseg head n)))
(assume (= (Union (Keyseg head x) (Keyseg x n)) (Keyseg head n)))
(assume (= (Union (SPKeyseg head x) (SPKeyseg x n)) (SPKeyseg head n))) /* implied by other lemmas */

(Post (and
 (Lseg head x)
 (= (next x) n)
 (List n)
 (List y)
 (= (Intersect (Sp (Lseg head x)) (Sp (Lseg x n))) EmptySetLoc)
 (= (Intersect (Sp (Lseg head x)) (Sp (List n))) EmptySetLoc)
 (= (Intersect (Sp (Lseg head x)) (Sp (List y))) EmptySetLoc)
 (= (Intersect (Sp (Lseg x n)) (Sp (List n))) EmptySetLoc)
 (= (Intersect (Sp (Lseg x n)) (Sp (List y))) EmptySetLoc)
 (= (Intersect (Sp (List n)) (Sp (List y))) EmptySetLoc)
 (= (Union (SetAdd (Keyseg head x) (key x)) (Union (Keys n) (Keys y))) (Union (Old (Keys head)) (Old (Keys y))))
))


/*VC: loop break to postcondition*/

(Pre (and
 (Lseg head x)
 (= (next x) n)
 (List n)
 (List y)
 (= (Intersect (Sp (Lseg head x)) (Sp (Lseg x n))) EmptySetLoc)
 (= (Intersect (Sp (Lseg head x)) (Sp (List n))) EmptySetLoc)
 (= (Intersect (Sp (Lseg head x)) (Sp (List y))) EmptySetLoc)
 (= (Intersect (Sp (Lseg x n)) (Sp (List n))) EmptySetLoc)
 (= (Intersect (Sp (Lseg x n)) (Sp (List y))) EmptySetLoc)
 (= (Intersect (Sp (List n)) (Sp (List y))) EmptySetLoc)
 (= (Union (SetAdd (Keyseg head x) (key x)) (Union (Keys n) (Keys y))) (Union (Old (Keys head)) (Old (Keys y))))
))


(assume (= n nil))
(assign (next n) y)
(assign ret head)

(Lemma (var1 var2)
(=>
 (and
  (Lseg var1 var2)
  (List var2))
 (List var1)
))

(Lemma (var1 var2)
(=
 (Union
  (Keyseg var1 var2)
  (Keys var2))
 (Keys var1)
))

(Post (and
 (List ret)
 (= (Keys ret) (Union (Old (Keys x)) (Old (Keys y))))
))
